This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
backend-README.md
main.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend-README.md">
# ROC Matrix Vista Backend

This is the FastAPI backend for the ROC Matrix Vista application, which provides data processing for ROC curves and confusion matrices.

## Features

- Generates synthetic probability and label data for demo purposes
- Calculates ROC curve points (TPR-FPR pairs) for different thresholds
- Computes confusion matrix metrics (TP, FP, TN, FN) for a given threshold
- Provides exact TPR/FPR metrics at the specified threshold
- Optimized implementation with precomputed ROC data

## API Endpoints

- `GET /api/metrics` - Get ROC curve data and confusion matrix with default threshold (0.5)
- `GET /api/metrics?threshold=<value>` - Get ROC curve data and confusion matrix for a specific threshold

## Response Format

```json
{
  "threshold": 0.5,
  "roc_curve": [
    { "threshold": 0.0, "tpr": 1.0, "fpr": 1.0 },
    { "threshold": 0.1, "tpr": 0.98, "fpr": 0.85 },
    ...
  ],
  "confusion_matrix": {
    "TP": 250,
    "FP": 120,
    "TN": 580,
    "FN": 50
  },
  "current_metrics": {
    "tpr": 0.833,
    "fpr": 0.171
  }
}
```

## Requirements

- Python 3.9+
- FastAPI
- Uvicorn
- NumPy

## Setup and Installation

1. Install dependencies:
   ```
   pip install fastapi uvicorn numpy
   ```

2. Run the server:
   ```
   python main.py
   ```
   
   Alternatively, you can use Uvicorn directly:
   ```
   uvicorn main:app --reload --host 0.0.0.0 --port 8000
   ```

3. The server will be available at http://localhost:8000

## API Documentation

FastAPI automatically generates interactive API documentation:

- Swagger UI: http://localhost:8000/docs
- ReDoc: http://localhost:8000/redoc

## Development

- The backend generates synthetic data on startup for demo purposes
- The ROC curve is precomputed once on startup for performance
- Confusion matrix data is computed on-the-fly for each threshold request
</file>

<file path="main.py">
from fastapi import FastAPI, Query
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import numpy as np

app = FastAPI()

# Configure CORS to allow frontend requests
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models
class ROCPoint(BaseModel):
    threshold: float
    tpr: float
    fpr: float

class ConfusionMatrix(BaseModel):
    TP: int
    FP: int
    TN: int
    FN: int

class MetricsResponse(BaseModel):
    threshold: float
    roc_curve: list[ROCPoint]
    confusion_matrix: ConfusionMatrix
    current_metrics: dict[str, float]  # New field for exact TPR/FPR at threshold

# Generate demo data
np.random.seed(42)  # For reproducibility
n_samples = 1000
true_labels = np.random.choice([0, 1], size=n_samples, p=[0.7, 0.3])  # 30% positives
predicted_probs = np.where(
    true_labels == 1,
    np.random.normal(0.7, 0.1, n_samples),  # Positives: mean 0.7, std 0.1
    np.random.normal(0.3, 0.1, n_samples)   # Negatives: mean 0.3, std 0.1
)
predicted_probs = np.clip(predicted_probs, 0, 1)  # Ensure probs are in [0,1]

# Precomputed ROC curve
roc_curve_data = []

# Computation functions
def compute_roc_curve(y_true: np.ndarray, y_score: np.ndarray) -> list[ROCPoint]:
    # Get unique thresholds (sorted)
    thresholds = np.unique(np.append(np.append(0, y_score), 1))
    thresholds = np.sort(thresholds)
    
    # Calculate ROC curve
    roc_points = []
    for threshold in thresholds:
        y_pred = (y_score >= threshold).astype(int)
        tp = np.sum((y_pred == 1) & (y_true == 1))
        fp = np.sum((y_pred == 1) & (y_true == 0))
        tn = np.sum((y_pred == 0) & (y_true == 0))
        fn = np.sum((y_pred == 0) & (y_true == 1))
        
        tpr = tp / (tp + fn) if (tp + fn) > 0 else 0
        fpr = fp / (fp + tn) if (fp + tn) > 0 else 0
        
        roc_points.append(ROCPoint(threshold=float(threshold), tpr=float(tpr), fpr=float(fpr)))
    
    return roc_points

def compute_confusion_matrix(y_true: np.ndarray, y_score: np.ndarray, threshold: float) -> ConfusionMatrix:
    y_pred = (y_score >= threshold).astype(int)
    tp = int(np.sum((y_pred == 1) & (y_true == 1)))
    fp = int(np.sum((y_pred == 1) & (y_true == 0)))
    tn = int(np.sum((y_pred == 0) & (y_true == 0)))
    fn = int(np.sum((y_pred == 0) & (y_true == 1)))
    return ConfusionMatrix(TP=tp, FP=fp, TN=tn, FN=fn)

def compute_metrics_at_threshold(y_true: np.ndarray, y_score: np.ndarray, threshold: float) -> dict[str, float]:
    y_pred = (y_score >= threshold).astype(int)
    tp = np.sum((y_pred == 1) & (y_true == 1))
    fp = np.sum((y_pred == 1) & (y_true == 0))
    tn = np.sum((y_pred == 0) & (y_true == 0))
    fn = np.sum((y_pred == 0) & (y_true == 1))
    
    tpr = float(tp / (tp + fn) if (tp + fn) > 0 else 0)
    fpr = float(fp / (fp + tn) if (fp + tn) > 0 else 0)
    
    return {"tpr": tpr, "fpr": fpr}

@app.on_event("startup")
def startup_event():
    global roc_curve_data
    roc_curve_data = compute_roc_curve(true_labels, predicted_probs)

@app.get("/api/metrics", response_model=MetricsResponse)
def get_metrics(threshold: float = Query(0.5, ge=0.0, le=1.0)):
    # Use precomputed ROC curve
    
    # Compute confusion matrix for the given threshold
    confusion_matrix = compute_confusion_matrix(true_labels, predicted_probs, threshold)
    
    # Compute current TPR/FPR at the threshold
    current_metrics = compute_metrics_at_threshold(true_labels, predicted_probs, threshold)
    
    return MetricsResponse(
        threshold=threshold,
        roc_curve=roc_curve_data,
        confusion_matrix=confusion_matrix,
        current_metrics=current_metrics
    )

@app.get("/")
def read_root():
    return {"message": "FastAPI backend is running"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
</file>

</files>
